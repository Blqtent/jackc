
class CompilationEngine {
	field int KEYWORD;
	field int SYMBOL;
	field int IDENTIFIER;
	field int INT_CONST;
	field int STRING_CONST;
	field int CLASS;
	field int METHOD;
	field int FUNCTION;
	field int CONSTRUCTOR;
	field int CALLBACK;
	field int INT;
	field int BOOLEAN;
	field int CHAR;
	field int VOID;
	field int VAR;
	field int STATIC;
	field int FIELD;
	field int LET;
	field int DO;
	field int IF;
	field int ELSE;
	field int WHILE;
	field int RETURN;
	field int TRUE;
	field int FALSE;
	field int NULL;
	field int THIS;
	field int ASM;
	field int LEFT_CURLY_BRACKET;
	field int RIGHT_CURLY_BRACKET;
	field int LEFT_PARENTHESIS;
	field int RIGHT_PARENTHESIS;
	field int LEFT_SQUARE_BRACKET;
	field int RIGHT_SQUARE_BRACKET;
	field int DOT;
	field int COMMA;
	field int SEMICOLON;
	field int PLUS;
	field int MINUS;
	field int MULTIPLY;
	field int DIV;
	field int AND;
	field int OR;
	field int GREATER;
	field int LESS;
	field int EQUAL;
	field int TILDE;
	//field Xml dst;
	
	field Xml x;
	field JackTokenizer jt;
	field File src;
	field int maxerror;
	field int nberror;
	field String exp;
	field boolean gen_xml;
	field int line;
	field int last_line;
	constructor CompilationEngine new(JackTokenizer source) 
	{
		let nberror = 0;
		let maxerror = 1;
		let src = null;
		let jt = source;
		let x = source.getXml();
		let gen_xml = true;

		let KEYWORD = x.getStringNoCreate("keyword");
		let SYMBOL = x.getStringNoCreate("symbol");
		let INT_CONST = x.getStringNoCreate("integerConstant");
		let STRING_CONST = x.getStringNoCreate("stringConstant");
		let IDENTIFIER = x.getStringNoCreate("identifier");
		let CLASS = x.getStringNoCreate("class");
		let METHOD = x.getStringNoCreate("method");
		let FUNCTION = x.getStringNoCreate("function");
		let CONSTRUCTOR = x.getStringNoCreate("constructor");
		let CALLBACK = x.getStringNoCreate("callback");
		let INT = x.getStringNoCreate("int");
		let BOOLEAN = x.getStringNoCreate("boolean");
		let CHAR = x.getStringNoCreate("char");
		let VOID = x.getStringNoCreate("void");
		let VAR = x.getStringNoCreate("var");
		let STATIC = x.getStringNoCreate("static");
		let FIELD = x.getStringNoCreate("field");
		let LET = x.getStringNoCreate("let");
		let DO = x.getStringNoCreate("do");
		let IF = x.getStringNoCreate("if");
		let ELSE = x.getStringNoCreate("else");
		let WHILE = x.getStringNoCreate("while");
		let RETURN = x.getStringNoCreate("return");
		let TRUE = x.getStringNoCreate("true");
		let FALSE = x.getStringNoCreate("false");
		let NULL = x.getStringNoCreate("null");
		let THIS = x.getStringNoCreate("this");
		let ASM = x.getStringNoCreate("#asm");
		let LEFT_CURLY_BRACKET = String.ord("{");
		let RIGHT_CURLY_BRACKET = String.ord("}");
		let LEFT_PARENTHESIS = String.ord("(");
		let RIGHT_PARENTHESIS = String.ord(")");
		let LEFT_SQUARE_BRACKET = String.ord("[");
		let RIGHT_SQUARE_BRACKET = String.ord("]");
		let DOT = String.ord(".");
		let COMMA = String.ord(",");
		let SEMICOLON = String.ord(";");
		let PLUS = String.ord("+");
		let MINUS = String.ord("-");
		let MULTIPLY = String.ord("*");
		let DIV = String.ord("/");
		let AND = String.ord("&");
		let OR = String.ord("|");
		let GREATER = String.ord(">");
		let LESS = String.ord("<");
		let EQUAL = String.ord("=");
		let TILDE = String.ord("~");
		return this;
	}

	method void dispose() {
		do Memory.deAlloc(this);
		return;
	}

	method void init(File source, boolean xml_output) {
		let src = source;
		let nberror = 0;
		let gen_xml = xml_output;
		let line = 0;
		let last_line = -1;
		return;
	}

	method boolean advance() {
		if (jt.hasMoreTokens()) {
			do jt.advance();
		} else {
			return false;
		}
		return true;
	}

	method void matched(String tok, int k) {
		var String s;
		return;
		do Output.printString(tok);
		if (tok = SYMBOL) {
			let s = String.new(8);
			let s = s.appendChar(k);
			do Output.printString(s);
			do s.dispose();
		} else {
			do Output.printInt(k);
		}
		do Output.println();
		return;
	}
 
	method boolean matchKeyword(String k, boolean eat) {	
		var String t;
		if (eat) {
		 	if (jt.hasMoreTokens()) {
				do jt.advance();
			} else {
				return false;
			}
		}
		let t = jt.tokenType();

		if (t = KEYWORD) {
			if (jt.keyWord() = k) {
				do matched(k, 0);
				return true;
			}
		}
		return false;
	}

	method boolean matchSymbol(char k, boolean eat) {	
		if (eat) {
			if (jt.hasMoreTokens()) {
				do jt.advance();
			} else {
				return false;
			}
		}
		if (jt.tokenType() = SYMBOL) {
			if (jt.symbol() = k) {
				do matched(SYMBOL, k);
				return true;
			}
		}
		return false;
	}

	method boolean matchIntegerConstant(boolean eat) {	
		if (eat) {
		 	if (jt.hasMoreTokens()) {
				do jt.advance();
			} else {
				return false;
			}
		}
		if (jt.tokenType() = INT_CONST) {
			do matched(INT_CONST, 0);
			return true;
		}
		return false;
	}

	method boolean matchStringConstant(boolean eat) {	
		if (eat) {
		 	if (jt.hasMoreTokens()) {
				do jt.advance();
			} else {
				return false;
			}
		}
		if (jt.tokenType() = STRING_CONST) {
			do matched(jt.stringVal(), 0);
			return true;
		}
		return false;
	}
	
	method boolean matchIdentifier(boolean eat) {	
		if (eat) {
		 	if (jt.hasMoreTokens()) {
				do jt.advance();
			} else {
				return false;
			}
		}
		if (jt.tokenType() = IDENTIFIER) {
			do matched(jt.identifier(), 0);
			return true;
		}
		return false;
	}
	
	method int error(String w) {
		var String s;

		let nberror = nberror + 1;
		if (nberror > maxerror) {
			return;
		}
		do Output.printString("Syntax error in ");
		do Output.printString(src.getName());
		do Output.printString(" ");
		do Output.printString(w);
		do Output.printString(" at line(");
		do Output.printInt(jt.getLine());
		do Output.printString(") got '");
		if (jt.tokenType() = KEYWORD) {
			do Output.printString(jt.keyWord());
		}
		if (jt.tokenType() = SYMBOL) {
			let s = String.new(3);
			let s = s.appendChar(jt.symbol());
			do Output.printString(s);
			do s.dispose();
		}
		if (jt.tokenType() = INT_CONST) {
			do Output.printInt(jt.intVal());
		}
		if (jt.tokenType() = STRING_CONST) {
			do Output.printString(jt.stringVal());
		}
		if (jt.tokenType() = IDENTIFIER) {
			do Output.printString(jt.identifier());
		}
		if (jt.tokenType() = ASM) {
			do Output.printString(jt.identifier());
		}
		if (jt.tokenType() = 0) {
			do Output.printString("end of file");
		}
		do Output.printString("'");
		do Output.println();
		return 0;
	}

	method void addLine() {
		var String u;
		if (jt.getLine() > last_line) {
			let last_line = jt.getLine();
			let u = String.new(8);
			let u = u.setInt(last_line);
			do x.addAttribute("line", u);
			do u.dispose();
		}
		return;
	}

	method void addStringConstant() {
		if (~gen_xml) {
			return;
		}
		do x.addElement(STRING_CONST);
		do x.addContent(jt.stringVal());
		do addLine();
		do x.closeCurrent();
		return;
	}

	method void addIntegerConstant() {
		var String s;
		if (~gen_xml) {
			return;
		}
		let s = String.new(8);
		let s = s.setInt(jt.intVal());
		do x.addElement(INT_CONST);
		do x.addContent(s);
		do s.dispose();
		do addLine();
		do x.closeCurrent();
		return;
	}
		
	method void addSymbol() {
		var String s;
		if (~gen_xml) {
			return;
		}
		do x.addElement(SYMBOL);
		let s = String.new(3);
		let s = s.appendChar(jt.symbol());
		do x.addContent(s);
		do s.dispose();
		do addLine();
		do x.closeCurrent();
		return;
	}

	method void addIdentifier() {
		if (~gen_xml) {
			return;
		}
		do x.addElement(IDENTIFIER);
		do x.addContent(jt.identifier());
		do addLine();
		do x.closeCurrent();
		return;
	}

	method void addKeyword() {
		if (~gen_xml) {
			return;
		}
		do x.addElement(KEYWORD);
		do x.addContent(jt.keyWord());
		do addLine();
		do x.closeCurrent();
		return;
	}
	
	method void begin(String nonTerminal) {
		if (~gen_xml) {
			return;
		}
		do x.addElement(nonTerminal);
	}

	method void end(String nonTerminal) {
		var XmlNode c;
		var String s;
		if (~gen_xml) {
			return;
		}
		do x.closeElement(nonTerminal);
		//do x.disposeCurrent();
/*
		let c = x.getCurrent();
		let s = c.getTag();
		while ((~(c.getParent()=null)) & s.compare(nonTerminal)) {
				
			do x.closeCurrent();
			let c = x.getCurrent();
			let s = c.getTag();
		}
*/
		return;		
	}

	method void compileClass(JackTokenizer tk, File dst_) {
		var boolean doit;
		let jt = tk;

		let doit = true; 
		if (~matchKeyword(CLASS, true)) {
			do error("Expected class");
			return;
		}
		do begin("class");
		do addKeyword();
		if (~matchIdentifier(true)) {
			do error("Expected class identifier");
			return;
		}
		do addIdentifier();			
		if (~matchSymbol(LEFT_CURLY_BRACKET, true)) {
			do error("Expected {");
			return;
		}
		do addSymbol();

		do advance();
		while (compileClassVarDec()) {
			let doit = doit; 
		}
		do compileCallbackDec();
		while (compileSubroutine()) {
			let doit = doit; 
		}
		if (~matchSymbol(RIGHT_CURLY_BRACKET, false)) {
			do error("Expected } ");
			return;
		}	
		do addSymbol();
		if (~(jt.hasMoreTokens() = 0)) {
			do error("Extra content after class definition");
			return;
		}	
		do end("class");
		return; // success
	}

	method boolean compileClassVarDec() {
		var boolean z;


		let z = matchKeyword(STATIC, false);
		let z = z | matchKeyword(FIELD, false);
		if (~z) {	
			return false;
		}

		do begin("classVarDec");
		do addKeyword();
	
		let z = matchKeyword(INT, true); // type
		let z = z | matchKeyword(CHAR, false);
		let z = z | matchKeyword(BOOLEAN, false);
		if (z) {
			do addKeyword();
		} else {
			let z = z | matchIdentifier(false);
			if (z) {
				do addIdentifier();
			}
		}
		if (~z) { 
			do error("type expected");
			return false;
		}					
		let z = matchIdentifier(true); // varName
		if (~z) {
			do error("varName expected.");	
			return false;
		}				
	
		do addIdentifier();
	
		let z = matchSymbol(COMMA, true); // ,
		while (z) {
 			// varName
			do addSymbol();
			let z = matchIdentifier(true);
			if (z) {
				do addIdentifier();
				let z = matchSymbol(COMMA, true);
				if (~z) {
					let z = matchSymbol(SEMICOLON, false);
					if (z) {
						do addSymbol();
						do advance();
						do end("classVarDec");
				  		return true;
					} else {
				  		do error(", or ; expected");
						return false;
					}
		    	    	}
			} else { 
				let z = matchSymbol(SEMICOLON, false);
				if (z) {
					do addSymbol();
					do advance();
					do end("classVarDec");
					return true;
				}
				do error(",varName expected");
				return false;
			} 
		}
		let z = matchSymbol(SEMICOLON, false);
		if (z) {
			do addSymbol();
			do advance();		
			do end("classVarDec");
			return true;
		} 
		do error("';' expected.");
		return false;
	}

	method boolean compileSubroutineBody() {
		var boolean z;
		let z = matchSymbol(LEFT_CURLY_BRACKET, false);
		if (z) {
			do addSymbol();
			do advance();
			let z = compileVarDec();
			let z = compileStatements();
			let z = matchSymbol(RIGHT_CURLY_BRACKET, false);
			if (z) {
				do addSymbol();
				do advance();
				return true;
			} 
			do error("'}' expected,,");
			return false;
		}
		do error("'{Í„' expected");
		return false;
	}

	method void compileCallbackDec() {
		var boolean z;
		let z = matchKeyword(CALLBACK, false);
		if (~z) {
			return;
		}
		do begin("callbackDec");
		let z = matchKeyword(INT, true); // type
		if (~z) {
			do error("'int' expected");
			return;
		}
		let z = matchKeyword(CALLBACK, true); // type
		if (~z) {
			do error("'int' expected");
			return;
		}
		let z = matchSymbol(LEFT_PARENTHESIS, true);
		if (~z) {
			do error("expect '('");
			return false;
		}				
		do addSymbol();

		do advance();
		let z = compileParameterList();
		if (~z) {
			return false;
		}
		let z = matchSymbol(RIGHT_PARENTHESIS, false);
		if (z) {
			do addSymbol();
			do advance();
			let z = compileSubroutineBody();
			do end("callbackDec");
			return z;
	    	}
	        do error("expect ')'.");
		return false;
		
	}

	method boolean compileSubroutine() {
		var boolean z;
		let z = matchKeyword(CONSTRUCTOR, false);
		let z = z | matchKeyword(FUNCTION, false);
		let z = z | matchKeyword(METHOD, false);
		if (~z) {
			return false;
		}
		do begin("subroutineDec");
		do addKeyword();

		let z = matchKeyword(VOID, true); // type
		let z = z | matchKeyword(INT, false);
		let z = z | matchKeyword(CHAR, false);
		let z = z | matchKeyword(BOOLEAN, false);
		if (z) {
			do addKeyword();
		} else {		
			let z = z | matchIdentifier(false);
			if (z) {
				do addIdentifier();
			}
		}
		if (~z) {
			do error("expect type");
			return false;
		}
		let z = matchIdentifier(true); // subroutinName
		if (~z) {
			do error("expect subroutineName");
			return false;
		}
		do addIdentifier();
			
		let z = matchSymbol(
			LEFT_PARENTHESIS, true);
		if (~z) {
			do error("expect '('");
			return false;
		}				
		do addSymbol();

		do advance();
		let z = compileParameterList();
		if (~z) {
			return false;
		}
		let z = matchSymbol(RIGHT_PARENTHESIS, false);
		if (z) {
			do addSymbol();
			do advance();
			let z = compileSubroutineBody();
			do end("subroutineDec");
			return z;
	    	}
	        do error("expect ')'.");
		return false;
	}

	method boolean compileParameterList() {
		var boolean z;
		let z = true;
		do begin("parameterList");
		while (jt.hasMoreTokens()) {
			let z = matchKeyword(INT, false); // type
			let z = z | matchKeyword(CHAR, false);
			let z = z | matchKeyword(BOOLEAN, false);
			if (z) {
				do addKeyword();
			} else {
				let z = z | matchIdentifier(false);
				if (z) {
					do addIdentifier();
				}
			}
			if (z) {
				let z = matchIdentifier(true); // varName
				if (z) {
					do addIdentifier();
					let z = matchSymbol(COMMA, true);
					if (~z) {
						do end("parameterList");
						return true;
					}
					do addSymbol();
				} else {	
					do error("varName expected..");
					return false;
				}
			} else {
				do end("parameterList");
				return true;
			}
			do advance();
		}
		return false;
	}

	method boolean compileVarDecVarList() {
		var boolean z;

		let z = matchIdentifier(true); // varName
		while (z) {
			do addIdentifier();
			let z = matchSymbol(COMMA, true);
			if (~z) {
				let z = matchSymbol(SEMICOLON, false);
				if (~z) {
				  	do error(", or ; expected");
				  	return false;	
				}
				do addSymbol();
				do advance();
				let z = false;
			} else {
			   	let z = matchIdentifier(true); //varName
			    	if (~z) {
			   		do error("varName expected..");
				  	return false;
			    	}				
			    	let z = true;
			}	
		} 	
		return true;
	}

	method boolean compileVarDec() {
		var boolean z;
		let z = true;
		let z = matchKeyword(VAR, false); //
		if (~z) {
			return false;
		}
		while (z) {
			do begin("varDec"); 
			do addKeyword();
			let z = matchKeyword(INT, true); // type
			let z = z | matchKeyword(CHAR, false);
			let z = z | matchKeyword(BOOLEAN, false);
			if (z) {
				do addKeyword();
			} else {
				let z = z | matchIdentifier(false);
				if (z) {
					do addIdentifier();
				}
			}
			if (z) {
				let z = compileVarDecVarList();
			}
			do end("varDec"); 
			let z = matchKeyword(VAR, false);  
		}
		return true;
	}

	method boolean compileStatements() {
		var boolean z;
		let z = true;
		do begin("statements"); 
		while (true) {
			let z = matchSymbol(RIGHT_CURLY_BRACKET, false);
			if (z) {
				do end("statements"); 
				return false;
			}
			if (matchKeyword(LET, false)) {
				do compileLet();
			} else { if (matchKeyword(DO, false)) {
				do compileDo();
			} else { if (matchKeyword(IF, false)) {
				do compileIf();
			} else { if (matchKeyword(WHILE, false)) {
				do compileWhile();
			} else { if (matchKeyword(RETURN, false)) {
				do compileReturn();
			} else { if (jt.tokenType() = ASM) {
				do advance();
			} else {
				do error("statement expected");
				return false;
			}}}}}}
		}
		return false;
	}

	method void compileDo() {
		var String s;
		var boolean z;
		var int l;

		if (~matchKeyword(DO, false)) {
			do error("do expected");
			return;
		}
		do begin("doStatement"); 

		if (~matchIdentifier(true)) { // subroutineName
			do error("subroutineName expected");
			return;
		}
		do addIdentifier();
		let s = jt.identifier();
		let s = s.copy();
		let l = jt.getLine();
		do advance();
		do subroutineCall(s, l);
		do s.dispose();
		let z = matchSymbol(SEMICOLON, false);
		if (~z) {	
			do error("';' expected..");
			return;
		}
		do addSymbol();
		do advance();
		do end("doStatement"); 
		return;
	}

	method void callbackCall() {
		var boolean z;
		if (~matchKeyword(CALLBACK, false)) {
			return;
		}
		let z = matchSymbol(LEFT_PARENTHESIS, true);
		if (~z) {
			do error("'(' expected");
		
		}
		do advance();
		do compileExpressionList();
		let z = matchSymbol(RIGHT_PARENTHESIS, false);
		if (~z) {
			do error("')' expected");
		}
		do advance();
		return;
		
	}
	method void subroutineCall(String subroutineName, int tokenLine) {
		var boolean z;
		let z = matchSymbol(LEFT_PARENTHESIS, false);
		if (z) {
			do addSymbol();
			do advance();
			do compileExpressionList();
			let z = matchSymbol(RIGHT_PARENTHESIS, false);
			if (~z) {	
				do error("')' expected");
				return;
			}
			do addSymbol();
			do advance();
			return;
		}
		let z = matchSymbol(DOT, false);
		if (~z) {
			do error("'(' or '.' expected");
			return;
		}
		do addSymbol();
		let z = matchIdentifier(true); // subroutineName
		if (~z) {
			do error("subroutineName expected");
			return;
		}
		do addIdentifier();
		let z = matchSymbol(LEFT_PARENTHESIS, true);
		if (~z) {
			do error("'(' expected");
			return;
		}
		do addSymbol();
		do advance();
		do compileExpressionList();
		let z = matchSymbol(RIGHT_PARENTHESIS, false);
		if (z) {
			do addSymbol();
			do advance();
			return;
		}
		do error("')' expected.");
		return;
	}

	method void compileLet() {
		var boolean z;
		do begin("letStatement");
		if (~matchKeyword(LET, false)) {
			do error("let expected");
			return;
		}

		do addKeyword();
		let z = matchIdentifier(true); 
		if (~z) {
			do error("varName expected");
			return;
		}
		do addIdentifier();
		let z = matchSymbol(LEFT_SQUARE_BRACKET, true);
		if (z) {
			do addSymbol();
			do advance();
			do compileExpression();
			let z = matchSymbol(RIGHT_SQUARE_BRACKET, false);
			if (~z) {	
				do error("']' expected");
				return;
			}
			do addSymbol();
			do advance();
		}
		let z = matchSymbol(EQUAL, false);
		if (~z) {
			do error("'=' expected");
			return;
		}
		do addSymbol();
		do advance();
		do compileExpression();
		let z = matchSymbol(SEMICOLON, false);
		if (~z) {
			do error("';' expected");
			return;
		}
		do addSymbol();
		do advance();
		do end("letStatement");
		return;
	}

	method void compileWhile() {
		var boolean z;
		
		if (~matchKeyword(WHILE, false)) {
			do error("while expected");
			return;
		}
		do begin("whileStatement");
		let z = matchSymbol(LEFT_PARENTHESIS, true);
		if (~z) {
			do error("'(' expected");
			return;
		}
		do addSymbol();	
		do advance();
		do compileExpression();
		let z = matchSymbol(RIGHT_PARENTHESIS, false);
		if (~z) {
			do error("')' expected");
			return;
		}
		do addSymbol();	
	
		let z = matchSymbol(LEFT_CURLY_BRACKET, true);
		if (~z) {
			do error("'{' expected");
			return;
		}
		do addSymbol();	
		do advance();
		do compileStatements();
		let z = matchSymbol(RIGHT_CURLY_BRACKET, false);
		if (~z) {
			do error("'}' expected,");
			return;
		}
		do addSymbol();	
		do end("whileStatement");
		do advance();
		return;
	}

	method void compileReturn() {
		var boolean z;
		if (~matchKeyword(RETURN, false)) {
			do error("return expected");
			return;
		}
		do begin("returnStatement");
		do addKeyword();
		do advance();

		do callbackCall();

		let z = matchSymbol(SEMICOLON, false);
		if (z) {
			do addSymbol();
			do advance();
			return;
		}
		do compileExpression();
		let z = matchSymbol(SEMICOLON, false);
		if (~z) {
			do error("';' expected...");
			return;
		}
		do addSymbol();
		do end("returnStatement");
		do advance();
		return;
	}

	method void compileIf() {
		var boolean z;
		if (~matchKeyword(IF, false)) {
			do error("if expected");
			return;
		}
		do begin("ifStatement");
		do addKeyword();
		let z = matchSymbol(LEFT_PARENTHESIS, true);
		if (~z) {
			do error("'(' expected");
			return;
		}
		do addSymbol();	
		do advance();
		do compileExpression();
		let z = matchSymbol(RIGHT_PARENTHESIS, false);
		if (~z) {
			do error("')' expected..");
			return;
		}
		do addSymbol();	
	
		let z = matchSymbol(LEFT_CURLY_BRACKET, true);
		if (~z) {
			do error("'{' expected");
			return;
		}
		do addSymbol();	
		do advance();
		do compileStatements();
		let z = matchSymbol(RIGHT_CURLY_BRACKET, false);
		if (~z) {
			do error("'}' expected.");
			return;
		}
		do addSymbol();	
		let z = matchKeyword(ELSE, true);
		if (~z) {
			do end("ifStatement");
			return;
		}
		do addKeyword();	
		let z = matchSymbol(LEFT_CURLY_BRACKET, true);
		if (~z) {
			do error("'{' expected");
			return;
		}
		do addSymbol();	
		do advance();
		do compileStatements();
		let z = matchSymbol(RIGHT_CURLY_BRACKET, false);
		if (~z) {
			do error("'}' expected..");
			return;
		}
		do addSymbol();	
		do end("ifStatement");
		do advance();
		return;
	}

	method void genOp() {
		var int c;
		let c = jt.symbol();
		if (c = PLUS) {
			return;
		}
		if (c = MINUS) {
			return;
		}
		if (c = MULTIPLY) {
			return;
		}
		if (c = DIV) {
			return;
		}
		if (c = AND) {
			return;
		}
		if (c = OR) {
			return;
		}
		if (c = GREATER) {
			return;
		}
		if (c = LESS) {
			return;
		}
		if (c = EQUAL) { 
			return;
		}
		do error("unexpected op.");
		return;
	}

	method void compileExpression() {
		var boolean z;
		do begin("expression");
		while (true) {
			do compileTerm();
			if (matchSymbol(SEMICOLON, false)) {
				do end("expression");
				return;
			}
			if (matchSymbol(RIGHT_PARENTHESIS, false)) {
				do end("expression");
				return;
			}
			if (matchSymbol(RIGHT_SQUARE_BRACKET, false)) {
				do end("expression");
				return;
			}
			if (matchSymbol(COMMA, false)) {
				do end("expression");
				return;
			}
			if (jt.tokenType() = SYMBOL) {
				do genOp();
				do addSymbol();
				if (~advance()) {
					do error(
						"missing token at end of file");
					return;
				}
			} else {
				do end("expression");
				return;
			}
		}	
		return;
	}

	method void compileTerm() {
		var boolean z;
		var String s;
		var int l;
		do begin("term");
		let z = matchIntegerConstant(false);
		if (z) {
			do addIntegerConstant();
			do end("term");
			do advance();
			return;
		}
		let z = matchStringConstant(false);
		if (z) {
			do addStringConstant();
			do end("term");
			do advance();
			return;
		}
		if (jt.tokenType() = KEYWORD) {
			if (matchKeyword(TRUE, false)) {
				do addKeyword();
				do end("term");
				do advance();
				return;
			} else { if (matchKeyword(FALSE, false)) {
				do addKeyword();
				do end("term");
				do advance();
				return;
			} else { if (matchKeyword(NULL, false)) {
				do addKeyword();
				do end("term");
				do advance();
				return;
			} else { if (matchKeyword(THIS, false)) {
				do addKeyword();
				do end("term");
				do advance();
				return;
			}}}}
		}
		let z = matchSymbol(TILDE, false);
		if (z) {
			do addSymbol();
			do advance();
			do compileTerm();
			do end("term");
			return;
		}
		let z = matchSymbol(MINUS, false);
		if (z) {
			do addSymbol();
			do advance();
			do compileTerm();
			do end("term");
			return;
		}

		let z = matchSymbol(RIGHT_PARENTHESIS, false);
		if (z) {
			do end("term");
			return;
		}

		let z = matchSymbol(LEFT_PARENTHESIS, false);
		if (z) {
			do addSymbol();
			do advance();
			do compileExpression();
			let z = matchSymbol(RIGHT_PARENTHESIS, false);
			if (z) {
				do addSymbol();
				do advance();
				do end("term");
				return;
			}
			do error("')' expected here");
			return;
		}
		
		// className varName subroutiN
		let z = matchIdentifier(false); 
		if (~z) {
			do error("Unexpected token...");
			return;
		}
		do addIdentifier();
		let s = jt.identifier();
		let s = s.copy();
		let l = jt.getLine();
		let z = matchSymbol(LEFT_SQUARE_BRACKET, true);
		if (z) {
			do addSymbol();
			do s.dispose();
			do advance();
			do compileExpression();
			let z = matchSymbol(RIGHT_SQUARE_BRACKET, false);
			if (~z) {
				do error("']' expected.");
				return;
			}
			do addSymbol();
			do end("term");
			do advance();
			return;
		}

		let z = matchSymbol(DOT, false);
		let z = z | matchSymbol(LEFT_PARENTHESIS, false);
		if (~z) {
			// match s
			do s.dispose();
			do end("term");
			return;
		}
		do subroutineCall(s, l);
		do s.dispose();
		do end("term");
		return;
	}

	method void compileExpressionList() {
		do begin("expressionList");
		do compileExpression();
		while (matchSymbol(COMMA, false)) {
			do addSymbol();
			do advance();
		 	do compileExpression();
		}
		do end("expressionList");
		return;
	}

}

