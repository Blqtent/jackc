
class CompilationEngine {
	field int KEYWORD;
	field int SYMBOL;
	field int IDENTIFIER;
	field int INT_CONST;
	field int STRING_CONST;
	field int CLASS;
	field int METHOD;
	field int FUNCTION;
	field int CONSTRUCTOR;
	field int INT;
	field int BOOLEAN;
	field int CHAR;
	field int VOID;
	field int VAR;
	field int STATIC;
	field int FIELD;
	field int LET;
	field int DO;
	field int IF;
	field int ELSE;
	field int WHILE;
	field int RETURN;
	field int TRUE;
	field int FALSE;
	field int NULL;
	field int THIS;
	field int ASM;
	field int LEFT_CURLY_BRACKET;
	field int RIGHT_CURLY_BRACKET;
	field int LEFT_PARENTHESIS;
	field int RIGHT_PARENTHESIS;
	field int LEFT_SQUARE_BRACKET;
	field int RIGHT_SQUARE_BRACKET;
	field int DOT;
	field int COMMA;
	field int SEMICOLON;
	field int PLUS;
	field int MINUS;
	field int MULTIPLY;
	field int DIV;
	field int AND;
	field int OR;
	field int GREATER;
	field int LESS;
	field int EQUAL;
	field int TILDE;
	//field Xml dst;
	
	field Xml x;
	field JackTokenizer jt;
	field File src;
	field int maxerror;
	field int nberror;
	field String exp;
	field boolean gen_xml;

	constructor CompilationEngine new(JackTokenizer source) 
	{
		let nberror = 0;
		let maxerror = 1;
		let src = null;
		let jt = source;
		let x = source.getXml();
		let gen_xml = true;

		let KEYWORD = x.getStringNoCreate("keyword");
		let SYMBOL = x.getStringNoCreate("symbol");
		let INT_CONST = x.getStringNoCreate("integerConstant");
		let STRING_CONST = x.getStringNoCreate("stringConstant");
		let IDENTIFIER = x.getStringNoCreate("identifier");
		let CLASS = x.getStringNoCreate("class");
		let METHOD = x.getStringNoCreate("method");
		let FUNCTION = x.getStringNoCreate("function");
		let CONSTRUCTOR = x.getStringNoCreate("constructor");
		let INT = x.getStringNoCreate("int");
		let BOOLEAN = x.getStringNoCreate("boolean");
		let CHAR = x.getStringNoCreate("char");
		let VOID = x.getStringNoCreate("void");
		let VAR = x.getStringNoCreate("var");
		let STATIC = x.getStringNoCreate("static");
		let FIELD = x.getStringNoCreate("field");
		let LET = x.getStringNoCreate("let");
		let DO = x.getStringNoCreate("do");
		let IF = x.getStringNoCreate("if");
		let ELSE = x.getStringNoCreate("else");
		let WHILE = x.getStringNoCreate("while");
		let RETURN = x.getStringNoCreate("return");
		let TRUE = x.getStringNoCreate("true");
		let FALSE = x.getStringNoCreate("false");
		let NULL = x.getStringNoCreate("null");
		let THIS = x.getStringNoCreate("this");
		let ASM = x.getStringNoCreate("#asm");
		let LEFT_CURLY_BRACKET = String.ord("{");
		let RIGHT_CURLY_BRACKET = String.ord("}");
		let LEFT_PARENTHESIS = String.ord("(");
		let RIGHT_PARENTHESIS = String.ord(")");
		let LEFT_SQUARE_BRACKET = String.ord("[");
		let RIGHT_SQUARE_BRACKET = String.ord("]");
		let DOT = String.ord(".");
		let COMMA = String.ord(",");
		let SEMICOLON = String.ord(";");
		let PLUS = String.ord("+");
		let MINUS = String.ord("-");
		let MULTIPLY = String.ord("*");
		let DIV = String.ord("/");
		let AND = String.ord("&");
		let OR = String.ord("|");
		let GREATER = String.ord(">");
		let LESS = String.ord("<");
		let EQUAL = String.ord("=");
		let TILDE = String.ord("~");
		return this;
	}

	method void dispose() {
		do Memory.deAlloc(this);
		return;
	}

	method void init(File source, boolean xml_output) {
		let src = source;
		let nberror = 0;
		let gen_xml = xml_output;
		return;
	}

	method boolean advance() {
		if (jt.hasMoreTokens()) {
			do jt.advance();
		} else {
			return false;
		}
		return true;
	}

	method void matched(String tok, int k) {
		var String s;
		return;
		do Output.printString(tok);
		if (tok = SYMBOL) {
			let s = String.new(8);
			let s = s.appendChar(k);
			do Output.printString(s);
			do s.dispose();
		} else {
			do Output.printInt(k);
		}
		do Output.println();
		return;
	}
 
	method boolean matchKeyword(String k, boolean eat) {	
		var String t;
		if (eat) {
		 	if (jt.hasMoreTokens()) {
				do jt.advance();
			} else {
				return false;
			}
		}
		let t = jt.tokenType();

		if (t = KEYWORD) {
			if (jt.keyWord() = k) {
				do matched(k, 0);
				return true;
			}
		}
		return false;
	}

	method boolean matchSymbol(char k, boolean eat) {	
		if (eat) {
			if (jt.hasMoreTokens()) {
				do jt.advance();
			} else {
				return false;
			}
		}
		if (jt.tokenType() = SYMBOL) {
			if (jt.symbol() = k) {
				do matched(SYMBOL, k);
				return true;
			}
		}
		return false;
	}

	method boolean matchIntegerConstant(boolean eat) {	
		if (eat) {
		 	if (jt.hasMoreTokens()) {
				do jt.advance();
			} else {
				return false;
			}
		}
		if (jt.tokenType() = INT_CONST) {
			do matched(INT_CONST, 0);
			return true;
		}
		return false;
	}

	method boolean matchStringConstant(boolean eat) {	
		if (eat) {
		 	if (jt.hasMoreTokens()) {
				do jt.advance();
			} else {
				return false;
			}
		}
		if (jt.tokenType() = STRING_CONST) {
			do matched(jt.stringVal(), 0);
			return true;
		}
		return false;
	}
	
	method boolean matchIdentifier(boolean eat) {	
		if (eat) {
		 	if (jt.hasMoreTokens()) {
				do jt.advance();
			} else {
				return false;
			}
		}
		if (jt.tokenType() = IDENTIFIER) {
			do matched(jt.identifier(), 0);
			return true;
		}
		return false;
	}
	
	method int error(String w) {
		var String s;

		let nberror = nberror + 1;
		if (nberror > maxerror) {
			return;
		}
		do Output.printString("Syntax error in ");
		do Output.printString(src.getName());
		do Output.printString(" ");
		do Output.printString(w);
		do Output.printString(" at line(");
		do Output.printInt(jt.getLine());
		do Output.printString(") got '");
		if (jt.tokenType() = KEYWORD) {
			do Output.printString(jt.keyWord());
		}
		if (jt.tokenType() = SYMBOL) {
			let s = String.new(3);
			let s = s.appendChar(jt.symbol());
			do Output.printString(s);
			do s.dispose();
		}
		if (jt.tokenType() = INT_CONST) {
			do Output.printInt(jt.intVal());
		}
		if (jt.tokenType() = STRING_CONST) {
			do Output.printString(jt.stringVal());
		}
		if (jt.tokenType() = IDENTIFIER) {
			do Output.printString(jt.identifier());
		}
		if (jt.tokenType() = ASM) {
			do Output.printString(jt.identifier());
		}
		if (jt.tokenType() = 0) {
			do Output.printString("end of file");
		}
		do Output.printString("'");
		do Output.println();
		return 0;
	}

	method void compileClass(JackTokenizer tk, File dst_) {
		var boolean doit;
		let jt = tk;

		let doit = true; 
		if (matchKeyword(CLASS, true)) {
			if (matchIdentifier(true)) {
				if (matchSymbol(LEFT_CURLY_BRACKET, true)) {
					do advance();
					while (compileClassVarDec()) {
						let doit = doit; 
					}
					while (compileSubroutine()) {
						let doit = doit; 
					}
					if (matchSymbol(
						RIGHT_CURLY_BRACKET, false)) 
					{
						if (jt.hasMoreTokens() = 0) {
							return;
						} else {
							do error("Extra content after class definition");
							return;
						}	
					}
					do error("Expected } ");
					return;
				}
				do error("Expected {");
				return;
			}
			do error("Expected class identifier");
			return;

		}
		do error("Expected class");
		return;

				/*do x.addElement(token_type);
				do x.addContent(token);
				do addLine();
				do x.closeCurrent();*/
	}

	method boolean compileClassVarDec() {
		var boolean z;
		let z = matchKeyword(STATIC, false);
		let z = z | matchKeyword(FIELD, false);
		if (z) {
			let z = matchKeyword(INT, true); // type
			let z = z | matchKeyword(CHAR, false);
			let z = z | matchKeyword(BOOLEAN, false);
			let z = z | matchIdentifier(false);
			if (z) { 
				let z = matchIdentifier(true); // varName
				if (z) {
					let z = matchSymbol(COMMA, true); // ,
					while (z) {
 						// varName
						let z = matchIdentifier(true);
						if (z) {
						    let z = matchSymbol(
								COMMA, true);
						    if (z = false) {
						        let z = matchSymbol(
							    	SEMICOLON, 
								false);
							if (z) {
							  do advance();
							  return true;
							} else {
							  do error(
							    ", or ; expected");
							  return false;
							}
					    	    }
						} else { 
							let z = matchSymbol(
								SEMICOLON, 
								false);
							if (z) {
								do advance();
								return true;
							}
							do error(
							  ",varName expected");
							return false;
						} 
					}
					let z = matchSymbol(SEMICOLON, false);
					if (z) {
						do advance();
						return true;
					} 
					do error("';' expected.");
					return false;
				}		
				do error("varName expected.");	
				return false;				
			}
			do error("type expected");
			return false;					
		}
		return false;
	}

	method boolean compileSubroutineBody() {
		var boolean z;
		let z = matchSymbol(LEFT_CURLY_BRACKET, false);
		if (z) {
			do advance();
			let z = compileVarDec();
			let z = compileStatements();
			let z = matchSymbol(RIGHT_CURLY_BRACKET, false);
			if (z) {
				do advance();
				return true;
			} 
			do error("'}' expected,,");
			return false;
		}
		do error("'{Í„' expected");
		return false;
	}

	method boolean compileSubroutine() {
		var boolean z;
		let z = matchKeyword(CONSTRUCTOR, false);
		let z = z | matchKeyword(FUNCTION, false);
		let z = z | matchKeyword(METHOD, false);
		if (z) {
			let z = matchKeyword(VOID, true); // type
			let z = z | matchKeyword(INT, false);
			let z = z | matchKeyword(CHAR, false);
			let z = z | matchKeyword(BOOLEAN, false);
			let z = z | matchIdentifier(false);
			if (z) {
				let z = matchIdentifier(true); // subroutinName
				if (z) {
					let z = matchSymbol(
						LEFT_PARENTHESIS, true);
					if (z) {
					    do advance();
					    let z = compileParameterList();
					    if (~z) {
						return false;
					    }
					    let z = matchSymbol(
							RIGHT_PARENTHESIS, 
							false);
					     if (z) {
						do advance();
						return compileSubroutineBody();
					     }
					     do error("expect ')'.");
					     return false;
					}
					do error("expect '('");
					return false;
				}
				do error("expect subroutineName");
				return false;
			}
			do error("expect type");
			return false;
		}
		return false;
	}

	method boolean compileParameterList() {
		var boolean z;
		let z = true;
		while (jt.hasMoreTokens()) {
			let z = matchKeyword(INT, false); // type
			let z = z | matchKeyword(CHAR, false);
			let z = z | matchKeyword(BOOLEAN, false);
			let z = z | matchIdentifier(false);
			if (z) {
				let z = matchIdentifier(true); // varName
				if (z) {
					let z = matchSymbol(COMMA, true);
					if (~z) {
						return true;
					}
				} else {	
					do error("varName expected..");
					return false;
				}
			} else {
				return true;
			}
			do advance();
		}
		return false;
	}

	method boolean compileVarDec() {
		var boolean z;
		let z = true;
		let z = matchKeyword(VAR, false); //
		if (~z) {
			return false;
		} 
		while (z) {
			let z = matchKeyword(INT, true); // type
			let z = z | matchKeyword(CHAR, false);
			let z = z | matchKeyword(BOOLEAN, false);
			let z = z | matchIdentifier(false);
			if (z) {
				let z = matchIdentifier(true); // varName
				while (z) {
					let z = matchSymbol(COMMA, true);
					if (~z) {
						let z = matchSymbol(
							SEMICOLON, 
							false);
						if (~z) {
						  do error(", or ; expected");
						  return false;	
						}
						do advance();
						let z = false;
					} else {
					   let z = matchIdentifier(
							true); //varName
					    if (~z) {
					   	do error("varName expected..");
						  return false;
					    }				
					    let z = true;
					}	
				} 	
			}
			let z = matchKeyword(VAR, false);  
		}
		return true;
	}

	method boolean compileStatements() {
		var boolean z;
		let z = true;
		while (true) {
			let z = matchSymbol(RIGHT_CURLY_BRACKET, false);
			if (z) {
				return false;
			}
			if (matchKeyword(LET, false)) {
				do advance();
				do compileLet();
			} else { if (matchKeyword(DO, false)) {
				do advance();
				do compileDo();
			} else { if (matchKeyword(IF, false)) {
				do advance();
				do compileIf();
			} else { if (matchKeyword(WHILE, false)) {
				do advance();
				do compileWhile();
			} else { if (matchKeyword(RETURN, false)) {
				do advance();
				do compileReturn();
			} else { if (jt.tokenType() = ASM) {
				do advance();
			} else {
				do error("statement expected");
				return false;
			}}}}}}
		}
		return false;
	}

	method void compileDo() {
		var String s;
		var boolean z;
		if (~matchIdentifier(false)) { // subroutineName
			do error("subroutineName expected");
			return;
		}
		let s = jt.identifier();
		let s = s.copy();
		do advance();
		do subroutineCall(s);
		do s.dispose();
		let z = matchSymbol(SEMICOLON, false);
		if (~z) {	
			do error("';' expected..");
			return;
		}
		do advance();
		return;
	}

	method void subroutineCall(String subroutineName) {
		var boolean z;
		let z = matchSymbol(LEFT_PARENTHESIS, false);
		if (z) {
			do advance();
			do compileExpressionList();
			let z = matchSymbol(RIGHT_PARENTHESIS, false);
			if (~z) {	
				do error("')' expected");
				return;
			}
			do advance();
			return;
		}
		let z = matchSymbol(DOT, false);
		if (z) {
			let z = matchIdentifier(true); // subroutineName
			if (z) {
				let z = matchSymbol(LEFT_PARENTHESIS, true);
				if (z) {
					do advance();
					do compileExpressionList();
					let z = matchSymbol(
						RIGHT_PARENTHESIS, false);
					if (z) {
						do advance();
						return;
					}
					do error("')' expected.");
					return;
				}
				do error("'(' expected");
				return;
			}
			do error("subroutineName expected");
			return;
		}
		do error("'(' or '.' expected");
		return;
	}

	method void compileLet() {
		var boolean z;
		let z = matchIdentifier(false); 
		if (~z) {
			do error("varName expected");
			return;
		}
		let z = matchSymbol(LEFT_SQUARE_BRACKET, true);
		if (z) {
			do advance();
			do compileExpression();
			let z = matchSymbol(RIGHT_SQUARE_BRACKET, false);
			if (~z) {	
				do error("']' expected");
				return;
			}
			do advance();
		}
		let z = matchSymbol(EQUAL, false);
		if (~z) {
			do error("'=' expected");
			return;
		}
		do advance();
		do compileExpression();
		let z = matchSymbol(SEMICOLON, false);
		if (~z) {
			do error("';' expected");
			return;
		}
		do advance();
		return;
	}

	method void compileWhile() {
		var boolean z;
		let z = matchSymbol(LEFT_PARENTHESIS, false);
		if (~z) {
			do error("'(' expected");
			return;
		}	
		do advance();
		do compileExpression();
		let z = matchSymbol(RIGHT_PARENTHESIS, false);
		if (~z) {
			do error("')' expected");
			return;
		}
	
		let z = matchSymbol(LEFT_CURLY_BRACKET, true);
		if (~z) {
			do error("'{' expected");
			return;
		}
		do advance();
		do compileStatements();
		let z = matchSymbol(RIGHT_CURLY_BRACKET, false);
		if (~z) {
			do error("'}' expected,");
			return;
		}
		do advance();
		return;
	}

	method void compileReturn() {
		var boolean z;
		let z = matchSymbol(SEMICOLON, false);
		if (z) {
			do advance();
			return;
		}
		do compileExpression();
		let z = matchSymbol(SEMICOLON, false);
		if (~z) {
			do error("';' expected...");
			return;
		}
		do advance();
		return;
	}

	method void compileIf() {
		var boolean z;
		let z = matchSymbol(LEFT_PARENTHESIS, false);
		if (~z) {
			do error("'(' expected");
			return;
		}	
		do advance();
		do compileExpression();
		let z = matchSymbol(RIGHT_PARENTHESIS, false);
		if (~z) {
			do error("')' expected..");
			return;
		}
	
		let z = matchSymbol(LEFT_CURLY_BRACKET, true);
		if (~z) {
			do error("'{' expected");
			return;
		}
		do advance();
		do compileStatements();
		let z = matchSymbol(RIGHT_CURLY_BRACKET, false);
		if (~z) {
			do error("'}' expected.");
			return;
		}
		let z = matchKeyword(ELSE, true);
		if (~z) {
			return;
		}
		let z = matchSymbol(LEFT_CURLY_BRACKET, true);
		if (~z) {
			do error("'{' expected");
			return;
		}
		do advance();
		do compileStatements();
		let z = matchSymbol(RIGHT_CURLY_BRACKET, false);
		if (~z) {
			do error("'}' expected..");
			return;
		}
		let z = matchKeyword(ELSE, true);
		if (~z) {
			return;
		}
		let z = matchSymbol(LEFT_CURLY_BRACKET, true);
		if (~z) {
			do error("'{' expected");
			return;
		}
		do advance();
		do compileStatements();
		let z = matchSymbol(RIGHT_CURLY_BRACKET, false);
		if (~z) {
			do error("'}' expected...");
			return;
		}
		do advance();
		return;
	}

	method void genOp() {
		var int c;
		let c = jt.symbol();
		if (c = PLUS) {
			return;
		}
		if (c = MINUS) {
			return;
		}
		if (c = MULTIPLY) {
			return;
		}
		if (c = DIV) {
			return;
		}
		if (c = AND) {
			return;
		}
		if (c = OR) {
			return;
		}
		if (c = GREATER) {
			return;
		}
		if (c = LESS) {
			return;
		}
		if (c = EQUAL) { 
			return;
		}
		do error("unexpected op.");
		return;
	}

	method void compileExpression() {
		var boolean z;

		while (true) {
			do compileTerm();
			if (matchSymbol(SEMICOLON, false)) {
				return;
			}
			if (matchSymbol(RIGHT_PARENTHESIS, false)) {
				return;
			}
			if (matchSymbol(RIGHT_SQUARE_BRACKET, false)) {
				return;
			}
			if (matchSymbol(COMMA, false)) {
				return;
			}
			if (jt.tokenType() = SYMBOL) {
				do genOp();
				if (~advance()) {
					do error(
						"missing token at end of file");
					return;
				}
			} else {
				return;
			}
		}	
		return;
	}

	method void compileTerm() {
		var boolean z;
		var String s;
		let z = matchIntegerConstant(false);
		if (z) {
			do advance();
			return;
		}
		let z = matchStringConstant(false);
		if (z) {
			do advance();
			return;
		}
		if (jt.tokenType() = KEYWORD) {
			if (matchKeyword(TRUE, false)) {
				do advance();
				return;
			} else { if (matchKeyword(FALSE, false)) {
				do advance();
				return;
			} else { if (matchKeyword(NULL, false)) {
				do advance();
				return;
			} else { if (matchKeyword(THIS, false)) {
				do advance();
				return;
			}}}}
			do error("Unespected keyword");
			return;
		}
		let z = matchSymbol(TILDE, false);
		if (z) {
			do advance();
			do compileTerm();
			return;
		}
		let z = matchSymbol(MINUS, false);
		if (z) {
			do advance();
			do compileTerm();
			return;
		}

		let z = matchSymbol(RIGHT_PARENTHESIS, false);
		if (z) {
			return;
		}

		let z = matchSymbol(LEFT_PARENTHESIS, false);
		if (z) {
			do advance();
			do compileExpression();
			let z = matchSymbol(RIGHT_PARENTHESIS, false);
			if (z) {
				do advance();
				return;
			}
			do error("')' expected here");
			return;
		}
		

		let z = matchIdentifier(false); // className varName subroutiN
		if (~z) {
			do error("Unexpected token...");
			return;
		}
		let s = jt.identifier();
		let s = s.copy();
		let z = matchSymbol(LEFT_SQUARE_BRACKET, true);
		if (z) {
			do s.dispose();
			do advance();
			do compileExpression();
			let z = matchSymbol(RIGHT_SQUARE_BRACKET, false);
			if (~z) {
				do error("']' expected.");
				return;
			}
			do advance();
			return;
		}

		let z = matchSymbol(DOT, false);
		let z = z | matchSymbol(LEFT_PARENTHESIS, false);
		if (~z) {
			// match s
			do s.dispose();
			return;
		}
		do subroutineCall(s);
		do s.dispose();
		return;
	}

	method void compileExpressionList() {
		do compileExpression();
		while (matchSymbol(COMMA, false)) {
			do advance();
		 	do compileExpression();
		}
		return;
	}

}

