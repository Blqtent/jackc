
class JackTokenizer {
	field File src;
	field Xml x;
	field int KEYWORD;
	field int SYMBOL;
	field int IDENTIFIER;
	field int INT_CONST;
	field int STRING_CONST;
	field int CLASS;
	field int METHOD;
	field int FUNCTION;
	field int CONSTRUCTOR;
	field int CALLBACK;
	field int INT;
	field int BOOLEAN;
	field int CHAR;
	field int VOID;
	field int VAR;
	field int STATIC;
	field int FIELD;
	field int LET;
	field int DO;
	field int IF;
	field int ELSE;
	field int WHILE;
	field int RETURN;
	field int TRUE;
	field int FALSE;
	field int NULL;
	field int THIS;
	field int ASM;
	field int LEFT_CURLY_BRACKET;
	field int RIGHT_CURLY_BRACKET;
	field int LEFT_PARENTHESIS;
	field int RIGHT_PARENTHESIS;
	field int LEFT_SQUARE_BRACKET;
	field int RIGHT_SQUARE_BRACKET;
	field int DOT;
	field int COMMA;
	field int SEMICOLON;
	field int PLUS;
	field int MINUS;
	field int MULTIPLY;
	field int DIV;
	field int AND;
	field int OR;
	field int GREATER;
	field int LESS;
	field int EQUAL;
	field int TILDE;
	field String token;
	field char c;
	field char ahead;
	field int token_type;
	field int key_word;
	field int int_val;
	field int line;
	field int last_line;
	field String new_file;
	field char symbol_;
	field boolean gen_xml;

	constructor JackTokeniser new(Xml destination) {
		let src = null;
		let x = destination;
		let token = String.new(256);
		let new_file = null;
		let c = 0;
		let line = 0;
		let last_line= -1;
		let ahead = 0;
		let token_type = -1;
		let key_word = 0;
		let symbol_ = 0;
		let int_val = 0;
		let gen_xml = false;
		let KEYWORD = x.getString("keyword");
		let SYMBOL = x.getString("symbol");
		let INT_CONST = x.getString("integerConstant");
		let STRING_CONST = x.getString("stringConstant");
		let IDENTIFIER = x.getString("identifier");
		let CLASS = x.getString("class");
		let METHOD = x.getString("method");
		let FUNCTION = x.getString("function");
		let CONSTRUCTOR = x.getString("constructor");
		let CALLBACK = x.getString("callback");
		let INT = x.getString("int");
		let BOOLEAN = x.getString("boolean");
		let CHAR = x.getString("char");
		let VOID = x.getString("void");
		let VAR = x.getString("var");
		let STATIC = x.getString("static");
		let FIELD = x.getString("field");
		let LET = x.getString("let");
		let DO = x.getString("do");
		let IF = x.getString("if");
		let ELSE = x.getString("else");
		let WHILE = x.getString("while");
		let RETURN = x.getString("return");
		let TRUE = x.getString("true");
		let FALSE = x.getString("false");
		let NULL = x.getString("null");
		let THIS = x.getString("this");
		let ASM = x.getString("#asm");
		let LEFT_CURLY_BRACKET = String.ord("{");
		let RIGHT_CURLY_BRACKET = String.ord("}");
		let LEFT_PARENTHESIS = String.ord("(");
		let RIGHT_PARENTHESIS = String.ord(")");
		let LEFT_SQUARE_BRACKET = String.ord("[");
		let RIGHT_SQUARE_BRACKET = String.ord("]");
		let DOT = String.ord(".");
		let COMMA = String.ord(",");
		let SEMICOLON = String.ord(";");
		let PLUS = String.ord("+");
		let MINUS = String.ord("-");
		let MULTIPLY = String.ord("*");
		let DIV = String.ord("/");
		let AND = String.ord("&");
		let OR = String.ord("|");
		let GREATER = String.ord(">");
		let LESS = String.ord("<");
		let EQUAL = String.ord("=");
		let TILDE = String.ord("~");
		
		return this;
	}

	method void dispose() {
		do token.dispose();
		do Memory.deAlloc(this);
		return;
	}

	method void init(File source, boolean generate_xml) {
		let src = source;
		if (src) {
			let new_file = src.getName();
		}
		let gen_xml = generate_xml;
		let c = 0;
		let ahead = 0;
		let token_type = -1;
		let key_word = 0;
		let int_val = 0;
		let line = 0;
		let last_line = -1;
	}

	method boolean hasMoreTokens() {
		var boolean in_comment;
		var boolean ignore_line;
		var int start;

		if (token_type = -1) {
			let c = src.readUtf8();
			let ahead = src.readUtf8();
			let token_type = 0;
		}

		let in_comment = false;
		let ignore_line = false;
		let start = line;
		while ((c > 0) & (c < 1114112)) { // U+0001 to U+00110000
			if (ignore_line) {
				if (c = 10) {
					let ignore_line = false;
				}
			} else { if (in_comment) {
				if (c = 42) { // *
					if (ahead = 47) { // /
						let in_comment = false;
						do next();			
					}
				} 
			} else {
				if (c = 47) { // /
					if (ahead = 42) { // *
						let start = line;
						let in_comment = true;
					} else { if (ahead = 47) {
						let ignore_line = true;
					} else {
						return true;
					}}
				} else {  if ((c = 9) | (c = 10) |
					 (c = 13) | (c = 32)) 
				{
					 // \t\n\r space
					let c = c;
				} else {
					return true;
				}}
			}}
			do next();			
		} 
		if (in_comment) {
			do error(start, "Comment toward end of file.");
		}	
		let token_type = 0;
		return false;
	}

	method void next() {	
		if (c = 10) {
			let line = line + 1;
		}
		let c = ahead;
		let ahead = src.readUtf8();
		return;
	}
	
	method void addLine() {
		var String u;
		if (line > last_line) {
			let u = String.new(8);
			let u = u.setInt(line + 1);
			do x.addAttribute("line", u);
			do u.dispose();
			let last_line = line;
		}
		if (new_file) {
			do x.addAttribute("file", new_file);
			let new_file = null;
		}
		return;
	}

	method void advance() {
		var int start;
		var int l;
		var String k;
		var boolean key_or_id;
		var boolean in_string;
		var boolean in_int;
		var boolean in_asm;
		let l = 0;
		let key_or_id = false;
		let in_string = false;
		let in_int = false;
		let in_asm = false;
		do token.setCharAt(0, 0);
		let start = line;			
		while ((c > 0) & (c < 1114112)) { // U+0001 to U+00110000
	
			if (in_string & (c = 34)) {
				let token_type = STRING_CONST;
				if (gen_xml) {
					do x.addElement(token_type);
					do x.addContent(token);
					do addLine();
					do x.closeCurrent();
				}
				do next();
				return;
			} else { if (in_int) { 
				if (((c > 47) & (c < 58))) {
					let token = token.appendChar(c);
					let l = l + 1;
				} else {
					let token_type = INT_CONST;
					if (gen_xml) {
						do x.addElement(token_type);
						do x.addContent(token);
						do addLine();
						do x.closeCurrent();
					}
					return;
				}
			} else { if (in_string) { 
				if (c = 10) {
					do error(line, "newline in string");
					return;
				}
				let token = token.appendChar(c);
				let l = l + 1;
			} else { if (in_asm) { 
				let token = token.appendChar(c);
				let l = l + 1;
				if (c = 10) {
					let token_type = ASM;
					if (gen_xml) {
						do x.addElement(token_type);
						do x.addContent(token);
						do addLine();
						do x.closeCurrent();
					}
					do next();
					return;
				}
			} else { if (c = 34) {
				let in_string = true;	
			} else { if (((c > 64) & (c < 91)) |
				((c > 96) & (c < 123)) |
				(c = 95) |
				((c > 47) & (c < 58) & (l > 0)))
			{
				let key_or_id = true;
				let token = token.appendChar(c);
				let l = l + 1;

			} else { if (key_or_id) {
				let k = x.getStringNoCreate(token);
				if ((k = CLASS) |
					(k = METHOD) |
					(k = FUNCTION) |
					(k = CONSTRUCTOR) |
					(k = CALLBACK) |
					(k = INT) |
					(k = BOOLEAN) |
					(k = CHAR) |
					(k = VOID) |
					(k = VAR) |
					(k = STATIC) |
					(k = FIELD) |
					(k = LET) |
					(k = DO) |
					(k = IF) |
					(k = ELSE) |
					(k = WHILE) |
					(k = RETURN) |
					(k = TRUE) |
					(k = FALSE) |
					(k = NULL) |
					(k = THIS))
				{
					let token_type = KEYWORD;
					let key_word = k;
				} else {
					let token_type = IDENTIFIER;

				}
				if (gen_xml) {
					do x.addElement(token_type);
					do x.addContent(token);
					do addLine();
					do x.closeCurrent();
				}
				return;
			} else { if (((c > 47) & (c < 58))) {
				let token = token.appendChar(c);
				let l = l + 1;
				let in_int = true;
			} else { if ((c = LEFT_CURLY_BRACKET) |
				(c = RIGHT_CURLY_BRACKET) |
				(c = LEFT_PARENTHESIS) |
				(c = RIGHT_PARENTHESIS) |
				(c = LEFT_SQUARE_BRACKET) |
				(c = RIGHT_SQUARE_BRACKET) |
				(c = DOT) |
				(c = COMMA) |
				(c = SEMICOLON) |
				(c = PLUS) |
				(c = MINUS) |
				(c = MULTIPLY) |
				(c = DIV) |
				(c = AND) |
				(c = OR) |
				(c = GREATER) |
				(c = LESS) |
				(c = EQUAL) |
				(c = TILDE)) 

			{
				let token_type = SYMBOL;
				let symbol_ = c;	
				let token = token.appendChar(c);
				if (gen_xml) {
					do x.addElement(token_type);
					do x.addContent(token);
					do addLine();
					do x.closeCurrent();
				}
				do next();
				return;
			} else {  if ((c = 9) | (c = 10) |
					 (c = 13) | (c = 32)) 
			{
				do error(line, "White space");
				let line = line;
			} else { if (c = 35) {
				let token = token.appendChar(c);
				let in_asm = true;
			} else {
				let token = token.appendChar(c);
				do error(line, token);
				do next();
				return;
			}}}}}}}}}}}
				  	
			do next();				
		}	
		if (in_string) {
			do error(start, "Comment toward end of file.");
		}
		if (in_int | key_or_id) {
			do error(start, "Reached end of file token.");
		}
		return;
	}

	method int error(int line_, String w) {
		do Output.printString("Lexer error, in ");
		do Output.printString(src.getName());
		do Output.printString(" unespected '");
		do Output.printString(w);
		do Output.printString("' at line ");
		do Output.printInt(line_ + 1);
		do Output.println();
		let c = 0;
		return 0;
	}

	method Xml getXml() {
		return x;
	}

	method int getLine() {
		return line + 1;
	}

	method int tokenType() {
		return token_type;
	}

	method int keyWord() {
		return key_word;
	}

	method char symbol() {
		return symbol_;
	}

	method String identifier() {
		return token;
	}

	method int intVal() {
		return token.intValue();
	}

	method String stringVal() {
		return token;
	}
}

